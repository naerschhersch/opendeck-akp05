use mirajazz::{error::MirajazzError, types::DeviceInput};

use crate::mappings::{ENCODER_COUNT, KEY_COUNT};

// TODO: These input mappings are placeholders and need to be verified with actual hardware
// The actual input codes will need to be discovered by testing with the real device
//
// Device layout: 10 regular buttons (2x5 grid) + 4 encoders with LCD touch zones
// Touch zones are rendered via write_lcd and display encoder functions automatically by OpenDeck

pub fn process_input(input: u8, state: u8) -> Result<DeviceInput, MirajazzError> {
    // Always emit a raw input line at debug for tracing
    log::debug!("Processing input: 0x{:02X}, state: {}", input, state);

    match input {
        // Physical LCD buttons (10 total: 2x5 grid)
        // TODO: Verify actual input codes with hardware - these are placeholders
        (0..=10) => read_button_press(input, state),

        // Touch zone tap events - mapped to encoder button presses
        // TODO: Discover actual input codes - these are placeholder values
        0x40..=0x43 => read_touch_tap(input, state),

        // Touchscreen swipe events (e.g., switch pages/profiles)
        // These are generated by the LCD touch strip
        // TODO: Verify actual input codes with hardware
        0x38 | 0x39 => read_touch_swipe(input, state),

        // Encoder rotation (4 encoders)
        0xA0 | 0xA1 | 0x50 | 0x51 | 0x90 | 0x91 | 0x70 | 0x71 => read_encoder_value(input),

        // Encoder press (4 encoders)
        0x33..=0x37 => read_encoder_press(input, state),

        _ => {
            // Unknown raw input; surface prominently to help mapping
            log::info!("EVENT Unknown code=0x{:02X} state={}", input, state);
            log::warn!("Unknown input code: 0x{:02X}, state: {}", input, state);
            Err(MirajazzError::BadData)
        }
    }
}

fn read_button_states(states: &[u8]) -> Vec<bool> {
    let mut bools = vec![];

    for i in 0..KEY_COUNT {
        bools.push(states[i + 1] != 0);
    }

    bools
}

fn read_button_press(input: u8, state: u8) -> Result<DeviceInput, MirajazzError> {
    let mut button_states = vec![0x01];
    button_states.extend(vec![0u8; KEY_COUNT + 1]);

    if input == 0 {
        return Ok(DeviceInput::ButtonStateChange(read_button_states(
            &button_states,
        )));
    }

    // TODO: Map actual N4 input codes to button indices (1-10)
    // This is a placeholder mapping that needs to be verified with real hardware
    let pressed_index: usize = match input {
        (1..=10) => input as usize, // 10 buttons for N4 (2x5 grid)
        _ => return Err(MirajazzError::BadData),
    };

    button_states[pressed_index] = state;

    // Log a concise, info-level event for recognized button presses
    log::info!("EVENT Button index={} state={}", pressed_index, state);

    Ok(DeviceInput::ButtonStateChange(read_button_states(
        &button_states,
    )))
}

fn read_encoder_value(input: u8) -> Result<DeviceInput, MirajazzError> {
    let mut encoder_values = vec![0i8; ENCODER_COUNT];

    let (encoder, value): (usize, i8) = match input {
        // Encoder 1
        0xA0 => (0, -1),
        0xA1 => (0, 1),
        // Encoder 2
        0x50 => (1, -1),
        0x51 => (1, 1),
        // Encoder 3
        0x90 => (2, -1),
        0x91 => (2, 1),
        // Encoder 4
        0x70 => (3, -1),
        0x71 => (3, 1),
        _ => return Err(MirajazzError::BadData),
    };

    encoder_values[encoder] = value;

    // Log recognized encoder twist
    log::info!("EVENT EncoderTwist encoder={} delta={}", encoder, value);
    Ok(DeviceInput::EncoderTwist(encoder_values))
}

fn read_encoder_press(input: u8, state: u8) -> Result<DeviceInput, MirajazzError> {
    let mut encoder_states = vec![false; ENCODER_COUNT];

    let encoder: usize = match input {
        0x37 => 0, // Encoder 1
        0x35 => 1, // Encoder 2
        0x33 => 2, // Encoder 3
        0x36 => 3, // Encoder 4
        _ => return Err(MirajazzError::BadData),
    };

    encoder_states[encoder] = state != 0;

    // Log recognized encoder press/release
    log::info!(
        "EVENT EncoderPress encoder={} state={}",
        encoder,
        encoder_states[encoder]
    );
    Ok(DeviceInput::EncoderStateChange(encoder_states))
}

/// Touchscreen swipe handler

fn read_touch_swipe(input: u8, state: u8) -> Result<DeviceInput, MirajazzError> {
    log::info!("EVENT TouchSwipe code=0x{:02X} state={}", input, state);
    Ok(DeviceInput::NoData)
}

fn read_touch_tap(input: u8, state: u8) -> Result<DeviceInput, MirajazzError> {
    // Touch zone taps are treated as encoder button presses
    // Note: OpenDeck handles touch zone rendering automatically for device type 7
    let mut encoder_states = vec![false; ENCODER_COUNT];

    let encoder = match input {
        0x40 => 0, // Encoder 0 touch zone tap
        0x41 => 1, // Encoder 1 touch zone tap
        0x42 => 2, // Encoder 2 touch zone tap
        0x43 => 3, // Encoder 3 touch zone tap
        _ => return Err(MirajazzError::BadData),
    };

    let active = state != 0;
    encoder_states[encoder] = active;

    log::info!("EVENT TouchTap encoder={} active={}", encoder, active);

    Ok(DeviceInput::EncoderStateChange(encoder_states))
}
